using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;

namespace SciSharp
{
    public class Matrix :IEnumerable<Nmbr>
    {
        #region Fields and Properties
        /// <summary>
        /// 
        /// </summary>
        public int Rows { get { return rows; } }

        /// <summary>
        /// 
        /// </summary>
        public int Cols { get { return cols; } }

        /// <summary>
        /// 
        /// </summary>
        public int Numel { get { return cols * rows; } }

        /// <summary>
        /// A collection of Lower and Upper Triangular Matrix Generated by LU factorization methods
        /// </summary>
        public Matrix L_lu { get; protected set; } = null;

        /// <summary>
        /// A collection of Lower and Upper Triangular Matrix Generated by LU factorization methods
        /// </summary>
        public Matrix U_lu { get; protected set; } = null;

        /// <summary>
        /// A collection of Lower and Upper Triangular Matrix Generated by cholesky factorization methods
        /// </summary>
        public Matrix L_chol { get; protected set; } = null;

        /// <summary>
        /// A collection of Lower and Upper Triangular Matrix Generated by cholesky factorization methods
        /// </summary>
        public Matrix U_chol { get; protected set; } = null;

        /// <summary>
        /// An Orthonormal Matrix Generated by SVD decomposition methods
        /// </summary>
        public Matrix U_svd { get; protected set; } = null;

        /// <summary>
        ///A Diagonal Matrix Generated by SVD decomposition methods
        /// </summary>
        public Matrix S_svd { get; protected set; } = null;

        /// <summary>
        ///  An Orthonormal Matrix Generated by SVD decomposition methods
        /// </summary>
        public Matrix V_svd { get; protected set; } = null;

        /// <summary>
        /// A Matrix Generated by BiDiagonal Reduction methods
        /// </summary>
        public Matrix U_bdr { get; protected set; } = null;

        /// <summary>
        /// A Matrix Generated by BiDiagonal Reduction methods
        /// </summary>
        public Matrix B_bdr { get; protected set; } = null;

        /// <summary>
        /// A Matrix Generated by BiDiagonal Reduction methods
        /// </summary>
        public Matrix V_bdr { get; protected set; } = null;

        /// <summary>
        /// A Matrix Generated by TriDiagonal Reduction methods
        /// </summary>
        public Matrix T_tdr { get; protected set; } = null;

        /// <summary>
        /// A Matrix Generated by TriDiagonal Reduction methods
        /// </summary>
        public Matrix Q_tdr { get; protected set; } = null;

        /// <summary>
        /// Q Matrix Generated by QR factorization methods
        /// </summary>
        public Matrix Q_qr { get; protected set; } = null;

        /// <summary>
        /// R Matrix Generated by QR factorization methods
        /// </summary>
        public Matrix R_qr { get; protected set; } = null;

        /// <summary>
        /// Permutation Matrix Generated by LU factorization methods
        /// </summary>
        public Matrix P;

        /// <summary>
        /// Matrix of EigenValues
        /// </summary>
        public Matrix EigVals { get; protected set; } = null;

        /// <summary>
        /// Matrix of EigenVectors
        /// </summary>
        public Matrix EigVecs { get; protected set; } = null;

        /// <summary>
        /// Array of Coefficient of Characteristics Polynomial
        /// </summary>
        public RowVec Charpoly { get; protected set; } = null;

        public string Message { get; protected set; }

        /// <summary>
        /// Array of interger for permutation
        /// </summary>
        public int[] pi;

        protected int rows, cols;
        protected List<List<Nmbr>> mat;
        bool isUpTri = false;
        bool isLowTri = false;
        bool isUpTriChecked = false;
        bool isLowTriChecked = false;
        bool isPosDef = false;
        bool luNotMade = true;
        bool charPolyNotMade = true;
        bool qrNotMade = true;
        bool cholNotMade = true;
        bool eigSysNotMade = true;
        bool triDiagNotmade = true;
        bool biDiagNotmade = true;
        bool svdNotmade = true;
        Nmbr detOfP = 1;
        #endregion

        public Matrix()
        { }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="entry"></param>
        public Matrix(double[,] entry)
        {
            rows = entry.GetLength(0);
            cols = entry.GetLength(1);
            mat = new List<List<Nmbr>>(rows);
            for (int i = 0; i < rows; i++)
            {
                mat[i] = new List<Nmbr>(cols);
                for (int j = 0; j < cols; j++)
                    mat[i][j] = entry[i, j];

            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="entry"></param>
        public Matrix(Cmplx[,] entry)
        {
            rows = entry.GetLength(0);
            cols = entry.GetLength(1);
            mat = new List<List<Nmbr>>(rows);
            for (int i = 0; i < rows; i++)
            {
                mat[i] = new List<Nmbr>(cols);
                for (int j = 0; j < cols; j++)
                    mat[i][j] = entry[i, j];

            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static implicit operator Matrix(double[,] value) => new Matrix(value);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public static implicit operator Matrix(Cmplx[,] value) => new Matrix(value);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="_rows"></param>
        /// <param name="_cols"></param>
        /// <param name="entry"></param>
        /// <param name="rows"></param>
        /// <param name="cols"></param>
        public Matrix(int[] _rows, int[] _cols, Cmplx[] entry, int rows, int cols)
        {
            this.rows = rows;  this.cols = cols;
            mat = new List<List<Nmbr>>(rows);
            for (int i = 0; i < rows; i++)
            {
                mat[i] = new List<Nmbr>(cols);
                for (int j = 0; j < cols; j++)
                    mat[i][j] = 0.0;
            }
            for (int i = 0; i < _rows.Length; i++)
                mat[_rows[i]][_cols[i]] += entry[i];
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public IEnumerator<Nmbr> GetEnumerator()
        {
            for (int j = 0; j < cols; j++)
                for (int i = 0; i < rows; i++)
                    yield return mat[i][j];
        }

        IEnumerator IEnumerable.GetEnumerator()
        { yield return GetEnumerator(); }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="N"></param>
        /// <param name="M"></param>
        /// <returns></returns>
        public static Matrix Zeros(int N, int M) => new double[N, M];
        

    }
}
